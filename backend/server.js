// --- Delete scheduled tweet endpoint ---
// Place this after app and models are initialized
// (Moved below, after app and models are initialized)
// --- Delete scheduled tweet endpoint ---


// --- Bulk scheduling endpoint (must be after app and models are initialized) ---
// Place this near other route definitions, after /schedule-tweet

// (Moved after app initialization)
// Background scheduler: checks every 30s for due scheduled tweets
setInterval(async () => {
    const now = new Date();
    try {
        const dueTweets = await ScheduledTweet.findAll({
            where: {
                status: 'pending',
                scheduledTime: { [require('sequelize').Op.lte]: now }
            }
        });
        for (const tweet of dueTweets) {
            try {
                // Post the tweet using the same logic as /post-tweet
                // Decrypt Twitter API keys before use
                const { decrypt } = require('./utils/crypto');
                let twitterClient = new TwitterApi({
                    appKey: decrypt(tweet.twitterApiKey),
                    appSecret: decrypt(tweet.twitterApiSecret),
                    accessToken: decrypt(tweet.twitterAccessToken),
                    accessSecret: decrypt(tweet.twitterAccessSecret),
                });
                let mediaId = null;
                if (tweet.imageUrl) {
                    // Download and upload image
                    const response = await fetch(tweet.imageUrl);
                    if (!response.ok) throw new Error('Failed to fetch image from URL');
                    const buffer = await response.buffer();
                    let ext = 'jpg';
                    if (tweet.imageUrl.endsWith('.png') || response.headers.get('content-type') === 'image/png') ext = 'png';
                    const tempPath = `uploads/scheduled-image-${Date.now()}.${ext}`;
                    require('fs').writeFileSync(tempPath, buffer);
                    mediaId = await twitterClient.v1.uploadMedia(tempPath);
                    require('fs').unlinkSync(tempPath);
                }
                const tweetPayload = { text: tweet.content };
                if (mediaId) tweetPayload.media = { media_ids: [mediaId] };
                const posted = await twitterClient.v2.tweet(tweetPayload);
                tweet.status = 'posted';
                tweet.postedTweetId = posted.data.id;
                await tweet.save();
                // Also save to Tweet table
                // Prevent duplicate tweet history entries
                const existing = await Tweet.findOne({ where: { twitterId: posted.data.id } });
                if (!existing) {
                    await Tweet.create({
                        userName: tweet.userName || 'Unknown',
                        content: tweet.content,
                        imageUrl: tweet.imageUrl || null,
                        twitterId: posted.data.id
                    });
                } else {
                }
            } catch (err) {
                tweet.status = 'failed';
                tweet.errorMessage = err.message;
                await tweet.save();
            }
        }
    } catch (err) {
    }
}, 30000);
// --- Sanitization helpers ---
// ...existing code...
// --- Sanitization helpers ---
const sanitizeInput = (str) => {
    if (typeof str !== 'string') return '';
    // Remove script tags and trim
    return str.replace(/<script.*?>.*?<\/script>/gi, '').replace(/[<>]/g, '').trim();
};

const sanitizeOutput = (str) => {
    if (typeof str !== 'string') return '';
    // Remove dangerous HTML and angle brackets
    let clean = str.replace(/<script.*?>.*?<\/script>/gi, '').replace(/[<>]/g, '');
    // Remove references to AI providers and generic AI mentions (case-insensitive, more aggressive)
    clean = clean.replace(/(OpenAI|Gemini|Perplexity|ChatGPT|Google AI|Anthropic|Claude|GPT-4|GPT-3|Bard|Llama|Meta AI|AI[- ]?powered|AI[- ]?generated|AI[- ]?assistant|AI[- ]?model|AI[- ]?system|AI[- ]?tool|AI[- ]?content|AI[- ]?response|AI[- ]?output|AI[- ]?suggestion|AI[- ]?tweet|AI[- ]?thread|AI\b|artificial intelligence|powered by AI|powered by artificial intelligence|by AI|using AI|created by AI|generated by AI|generated with AI|written by AI|written with AI|assistant|language model|machine learning model|machine learning)/gi, '');
    // Remove brackets [] () {} and equal signs
    clean = clean.replace(/[\[\](){}=]/g, '');
    // Remove extra whitespace left by replacements
    clean = clean.replace(/\s{2,}/g, ' ');
    return clean.trim();
};
// Helper to validate API keys (not empty, not placeholder)
function isValidOpenAIKey(key) {
    if (!key || typeof key !== 'string') return false;
    const trimmed = key.trim();
    // OpenAI keys typically start with 'sk-' and are longer than 20 chars
    return trimmed.startsWith('sk-') && trimmed.length > 20;
}

// Provider-specific key validator
function isValidKey(key, provider) {
    if (!key || typeof key !== 'string') return false;
    const trimmed = key.trim();
    if (provider === 'openai') return trimmed.startsWith('sk-') && trimmed.length > 20;
    if (provider === 'perplexity') return trimmed.startsWith('pplx-') && trimmed.length > 20;
    if (provider === 'gemini') return trimmed.startsWith('AIza') && trimmed.length > 20;
    return false;
}
require('dotenv').config({ path: __dirname + '/.env' });

const express = require('express');
const { DateTime } = require('luxon');
const cors = require('cors');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const { TwitterApi } = require('twitter-api-v2');
// const OpenAI = require('openai');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const OpenAI = require('openai');
const fetch = require('node-fetch');
const sequelize = require('./db');
const cookieParser = require('cookie-parser');

const app = express();

// Parse JSON bodies for all requests
app.use(express.json());

// Parse cookies
app.use(cookieParser());

// Enable CORS for all routes
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
}));

const TweetModel = require('./models/tweet');
const ScheduledTweetModel = require('./models/scheduledTweet');
const User = require('./models/user');

// Initialize Sequelize models
const Tweet = TweetModel(sequelize);
const ScheduledTweet = ScheduledTweetModel(sequelize);

// Import auth routes
const authRoutes = require('./routes/auth');

sequelize.sync().then(() => {
});

// --- Delete scheduled tweet endpoint ---
// Now correctly placed after app and models are initialized
app.delete('/scheduled-tweets/:id', async (req, res) => {
    try {
        const tweetId = req.params.id;
        const tweet = await ScheduledTweet.findByPk(tweetId);
        if (!tweet) {
            return res.status(404).json({ success: false, message: "Scheduled tweet not found" });
        }
        await tweet.destroy();
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ success: false, message: "Failed to delete scheduled tweet", error: error.message });
    }
});
// --- Delete scheduled tweet endpoint ---


// Configure multer for image uploads
const upload = multer({
    dest: 'uploads/',
    limits: {
        fileSize: 10 * 1024 * 1024, // 5MB limit
    },
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Only image files are allowed!'), false);
        }
    }
});

// Create uploads directory if it doesn't exist
if (!fs.existsSync('uploads')) {
    fs.mkdirSync('uploads');
}

const ACCESS_CODE = process.env.ACCESS_CODE || "tweetmaster2025";
const PORT = process.env.PORT || 5000;

// OpenAI support removed

let openaiClient = null;
if (process.env.OPENAI_API_KEY) {
    openaiClient = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
    });
} else {
}

// Initialize Gemini client
let geminiClient = null;
let geminiModel = null;
if (process.env.GEMINI_API_KEY) {
    geminiClient = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    geminiModel = geminiClient.getGenerativeModel({ model: "gemini-1.5-flash" });
} else {
}

// Initialize Twitter client
let twitterClient = null;
if (process.env.TWITTER_API_KEY && process.env.TWITTER_API_SECRET &&
    process.env.TWITTER_ACCESS_TOKEN && process.env.TWITTER_ACCESS_SECRET) {

    twitterClient = new TwitterApi({
        appKey: process.env.TWITTER_API_KEY,
        appSecret: process.env.TWITTER_API_SECRET,
        accessToken: process.env.TWITTER_ACCESS_TOKEN,
        accessSecret: process.env.TWITTER_ACCESS_SECRET,
    });
} else {
}

// Health check endpoint for Railway
app.get('/', (req, res) => {
    res.json({
        status: 'tweetgenie Backend is running!',
        timestamp: new Date().toISOString(),
        services: {
            twitter: !!twitterClient,
            gemini: !!geminiClient,
            // openai: !!openaiClient
        }
    });
});

// Auth endpoint
app.post('/auth', (req, res) => {
    const { password } = req.body;
    if (password === ACCESS_CODE) {
        res.json({ success: true, message: "Access granted!" });
    } else {
        res.json({ success: false, message: "Invalid access code" });
    }
});

// Authentication routes
app.use('/api/auth', authRoutes);

// Generate tweet endpoint

const { encrypt } = require('./utils/crypto');

app.post('/generate-tweet', async (req, res) => {
    // Sanitize input
    req.body.aiPrompt = sanitizeInput(req.body.aiPrompt);
    let {
        userName,
        openaiApiKey,
        perplexityApiKey,
        geminiApiKey,
        twitterApiKey,
        twitterApiSecret,
        twitterAccessToken,
        twitterAccessSecret,
        aiPrompt,
        useOwnKeys // true if user provides their own keys, false for pre-existing
    } = req.body;

    // Declare valid*Key variables at the top
    let validOpenaiKey = null;
    let validPerplexityKey = null;
    let validGeminiKey = null;

    // Validate and encrypt user-supplied AI keys if present and useOwnKeys is true
    if (useOwnKeys) {
        if (openaiApiKey && isValidKey(openaiApiKey, 'openai')) {
            openaiApiKey = encrypt(openaiApiKey);
        } else {
            openaiApiKey = null;
        }
        if (perplexityApiKey && isValidKey(perplexityApiKey, 'perplexity')) {
            perplexityApiKey = encrypt(perplexityApiKey);
        } else {
            perplexityApiKey = null;
        }
        if (geminiApiKey && isValidKey(geminiApiKey, 'gemini')) {
            geminiApiKey = encrypt(geminiApiKey);
        } else {
            geminiApiKey = null;
        }
        // Debug: print encrypted keys
        console.log('Encrypted user keys:', { openaiApiKey, perplexityApiKey, geminiApiKey });
        // Always use decrypted value for provider selection and API calls
        const decryptedOpenai = maybeDecrypt(openaiApiKey);
        const decryptedPerplexity = maybeDecrypt(perplexityApiKey);
        const decryptedGemini = maybeDecrypt(geminiApiKey);
        validOpenaiKey = isValidKey(decryptedOpenai, 'openai') ? decryptedOpenai : null;
        validPerplexityKey = isValidKey(decryptedPerplexity, 'perplexity') ? decryptedPerplexity : null;
        validGeminiKey = isValidKey(decryptedGemini, 'gemini') ? decryptedGemini : null;
        // Debug: print decrypted keys and validation after decrypt
        console.log('Decrypted user keys:', { validOpenaiKey, validPerplexityKey, validGeminiKey });
        console.log('Validation results after decrypt:', {
            openai: validOpenaiKey && isValidKey(validOpenaiKey, 'openai'),
            perplexity: validPerplexityKey && isValidKey(validPerplexityKey, 'perplexity'),
            gemini: validGeminiKey && isValidKey(validGeminiKey, 'gemini')
        });
    } else {
        // fallback to .env
        validOpenaiKey = process.env.OPENAI_API_KEY;
        validPerplexityKey = process.env.PERPLEXITY_API_KEY;
        validGeminiKey = process.env.GEMINI_API_KEY;
    }

    // Strictly use only keys from the selected source
    let providerOrder;
    if (useOwnKeys) {
        // Only use keys provided by the user, never fallback to .env
        providerOrder = [];
        // Only add provider if key is present AND provider is selected by frontend
        if (req.body.aiProviders && Array.isArray(req.body.aiProviders)) {
            if (validPerplexityKey && req.body.aiProviders.includes('perplexity')) providerOrder.push('perplexity');
            if (validOpenaiKey && req.body.aiProviders.includes('openai')) providerOrder.push('openai');
            if (validGeminiKey && req.body.aiProviders.includes('gemini')) providerOrder.push('gemini');
        } else {
            // fallback: add any valid key
            if (validPerplexityKey) providerOrder.push('perplexity');
            if (validOpenaiKey) providerOrder.push('openai');
            if (validGeminiKey) providerOrder.push('gemini');
        }
    } else {
        // Only use keys from .env, never use user-provided keys
        validPerplexityKey = isValidKey(process.env.PERPLEXITY_API_KEY, 'perplexity') ? process.env.PERPLEXITY_API_KEY : null;
        validGeminiKey = isValidKey(process.env.GEMINI_API_KEY, 'gemini') ? process.env.GEMINI_API_KEY : null;
        validOpenaiKey = isValidKey(process.env.OPENAI_API_KEY, 'openai') ? process.env.OPENAI_API_KEY : null;
        providerOrder = [];
        if (validPerplexityKey) providerOrder.push('perplexity');
        if (validOpenaiKey) providerOrder.push('openai');
        if (validGeminiKey) providerOrder.push('gemini');
    }
    // Extra debug log
    console.log('Provider order:', providerOrder);
    console.log('Valid keys:', { validPerplexityKey, validGeminiKey, validOpenaiKey });

    // Always generate a tweet specifically about what the user asked
    const prompt = aiPrompt && aiPrompt.trim()
        ? `Generate an engaging, creative tweet specifically about: ${aiPrompt}. Include relevant emojis if appropriate.`
        : `Generate an engaging, creative tweet about any topic. Include relevant emojis if appropriate.`;

    const axios = require('axios');
    let generatedTweet = '';
    try {
        for (const provider of providerOrder) {
            if (provider === 'perplexity' && validPerplexityKey && !generatedTweet) {
                console.log('Trying Perplexity API key:', validPerplexityKey);
                try {
                    const resp = await axios.post('https://api.perplexity.ai/chat/completions', {
                        model: 'sonar-pro',
                        messages: [{ role: 'user', content: prompt }],
                    }, {
                        headers: { 'Authorization': `Bearer ${validPerplexityKey}` }
                    });
                    generatedTweet = resp.data.choices[0].message.content.trim();
                    console.log('✅ Generated tweet with Perplexity:', generatedTweet);
                } catch (err) {
                    console.error('Perplexity error:', err?.response?.data || err?.message || err);
                }
            }
            if (provider === 'openai' && validOpenaiKey && !generatedTweet) {
                try {
                    const OpenAI = require('openai');
                    const openaiClient = new OpenAI({ apiKey: validOpenaiKey });
                    const completion = await openaiClient.chat.completions.create({
                        model: "gpt-3.5-turbo",
                        messages: [
                            {
                                role: "system",
                                content: "You are a social media expert creating engaging, concise, and shareable tweets. Keep each tweet under 280 characters, add personality, and encourage engagement.\n\n"
                            },
                            {
                                role: "user",
                                content: prompt
                            }
                        ],
                        max_tokens: 100,
                        temperature: 0.8,
                    });
                    generatedTweet = completion.choices[0].message.content.trim();
                    console.log('✅ Generated tweet with OpenAI:', generatedTweet);
                } catch (err) {
                    console.error('OpenAI error:', err?.response?.data || err?.message || err);
                }
            }
            if (provider === 'gemini' && validGeminiKey && !generatedTweet) {
                try {
                    const { GoogleGenerativeAI } = require('@google/generative-ai');
                    const geminiClient = new GoogleGenerativeAI(validGeminiKey);
                    const geminiModel = geminiClient.getGenerativeModel({ model: "gemini-1.5-flash" });
                    const result = await geminiModel.generateContent(
                        `You are a social media expert creating engaging, concise, and shareable tweets. Keep each tweet under 280 characters, add personality, and encourage engagement.\n\n${prompt}`
                    );
                    const response = result.response;
                    generatedTweet = response.text().trim();
                    console.log('✅ Generated tweet with Gemini:', generatedTweet);
                } catch (err) {
                    console.error('Gemini error:', err?.response?.data || err?.message || err);
                }
            }
        }
        if (!generatedTweet) {
            return res.json({
                success: false,
                message: "AI generation disabled. Add Perplexity, Gemini, or OpenAI API key to enable this feature."
            });
        }
        // Remove quotes if the AI added them
        const cleanTweet = sanitizeOutput(generatedTweet.replace(/^[["']|["']]$/g, ''));
        const wordCount = cleanTweet.split(/\s+/).filter(Boolean).length;
        if (wordCount > 280) {
            return res.json({ success: false, message: "Tweet content exceeds 280 words." });
        }
        res.json({
            success: true,
            content: cleanTweet,
            message: "Tweet generated successfully!"
        });
    } catch (error) {
        console.error('❌ Error generating tweet:', error);
        res.status(500).json({
            success: false,
            message: "Failed to generate tweet",
            error: error.message
        });
    }
});

// --- /generate-ai-image endpoint (fixed) ---
app.post('/generate-ai-image', async (req, res) => {
    console.log('=== IMAGE GENERATION DEBUG ===');
    console.log('Request body:', JSON.stringify(req.body, null, 2));
    console.log('Content-Type:', req.headers['content-type']);

    const { prompt, useOwnKeys, openaiApiKey } = req.body;

    console.log('Extracted values:');
    console.log('- prompt:', prompt);
    console.log('- useOwnKeys:', useOwnKeys);
    console.log('- openaiApiKey length:', openaiApiKey ? openaiApiKey.length : 0);

    // Simple prompt validation
    if (!prompt || typeof prompt !== 'string' || !prompt.trim()) {
        return res.status(400).json({
            success: false,
            message: "Prompt is required and cannot be empty."
        });
    }

    // Simple OpenAI key validation
    let validOpenaiKey;
    if (useOwnKeys) {
        const { decrypt } = require('./utils/crypto');
        if (openaiApiKey && typeof openaiApiKey === 'string') {
            try {
                const decryptedKey = maybeDecrypt(openaiApiKey);
                if (decryptedKey.trim().startsWith('sk-') && decryptedKey.trim().length > 20) {
                    validOpenaiKey = decryptedKey.trim();
                    console.log('Using user-provided OpenAI key (decrypted if needed)');
                } else {
                    throw new Error('Decrypted OpenAI key invalid');
                }
            } catch (e) {
                console.log('Invalid user-provided OpenAI key (decryption failed)');
                return res.status(400).json({
                    success: false,
                    message: "Valid OpenAI API key required (must start with 'sk-' and be longer than 20 chars)"
                });
            }
        } else {
            console.log('Invalid user-provided OpenAI key');
            return res.status(400).json({
                success: false,
                message: "Valid OpenAI API key required (must start with 'sk-' and be longer than 20 chars)"
            });
        }
    } else {
        validOpenaiKey = process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY.trim().startsWith('sk-') && process.env.OPENAI_API_KEY.trim().length > 20 ? process.env.OPENAI_API_KEY.trim() : null;
        console.log('Using environment OpenAI key:', !!validOpenaiKey);
    }

    if (!validOpenaiKey) {
        return res.status(400).json({
            success: false,
            message: "No valid OpenAI API key available."
        });
    }

    const cleanPrompt = prompt.trim();
    const enhancedPrompt = `Create a high-quality, visually engaging image for social media. ${cleanPrompt}`;

    try {
        console.log('Attempting OpenAI image generation...');
        const openaiClient = new OpenAI({ apiKey: validOpenaiKey });
        const response = await openaiClient.images.generate({
            prompt: enhancedPrompt,
            n: 1,
            size: "1024x1024",
            response_format: "url"
        });
        console.log('OpenAI image generation successful');
        return res.json({
            success: true,
            image: response.data[0].url,
            provider: "openai"
        });
    } catch (error) {
        console.error('OpenAI error:', error);
        if (error.code === 'invalid_api_key') {
            return res.status(401).json({
                success: false,
                message: "Invalid OpenAI API key. Please check your key and try again.",
                error: "Authentication failed"
            });
        }
        if (error.code === 'insufficient_quota') {
            return res.status(402).json({
                success: false,
                message: "OpenAI API quota exceeded. Please check your billing.",
                error: "Quota exceeded"
            });
        }
        return res.status(500).json({
            success: false,
            message: "Image generation failed",
            error: error.message
        });
    }
});

// --- /generate-thread endpoint ---
app.post('/generate-thread', async (req, res) => {
    const { prompt, aiProviders, useOwnKeys, perplexityApiKey, geminiApiKey, openaiApiKey } = req.body;
    const cleanPrompt = sanitizeInput(prompt);
    if (!cleanPrompt) {
        return res.status(400).json({ success: false, message: 'Prompt is required to generate a thread.' });
    }

    // Determine which keys to use (mirroring /generate-tweet logic)
    let validPerplexityKey, validGeminiKey, validOpenaiKey, providerOrder;
    if (useOwnKeys) {
        validPerplexityKey = perplexityApiKey && typeof perplexityApiKey === 'string' && perplexityApiKey.trim() ? perplexityApiKey : null;
        validGeminiKey = geminiApiKey && typeof geminiApiKey === 'string' && geminiApiKey.trim() ? geminiApiKey : null;
        validOpenaiKey = openaiApiKey && typeof openaiApiKey === 'string' && openaiApiKey.trim() ? openaiApiKey : null;
        providerOrder = [];
        if (aiProviders && Array.isArray(aiProviders)) {
            if (validPerplexityKey && aiProviders.includes('perplexity')) providerOrder.push('perplexity');
            if (validOpenaiKey && aiProviders.includes('openai')) providerOrder.push('openai');
            if (validGeminiKey && aiProviders.includes('gemini')) providerOrder.push('gemini');
        } else {
            if (validPerplexityKey) providerOrder.push('perplexity');
            if (validOpenaiKey) providerOrder.push('openai');
            if (validGeminiKey) providerOrder.push('gemini');
        }
    } else {
        validPerplexityKey = process.env.PERPLEXITY_API_KEY && process.env.PERPLEXITY_API_KEY.trim() ? process.env.PERPLEXITY_API_KEY : null;
        validGeminiKey = process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY.trim() ? process.env.GEMINI_API_KEY : null;
        validOpenaiKey = process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY.trim() ? process.env.OPENAI_API_KEY : null;
        providerOrder = [];
        if (validPerplexityKey) providerOrder.push('perplexity');
        if (validOpenaiKey) providerOrder.push('openai');
        if (validGeminiKey) providerOrder.push('gemini');
    }

    let threadTweets = [];
    try {
        let aiError = null;
        for (const provider of providerOrder) {
            if (provider === 'perplexity' && validPerplexityKey && threadTweets.length === 0) {
                try {
                    const axios = require('axios');
                    const resp = await axios.post('https://api.perplexity.ai/chat/completions', {
                        model: 'sonar-pro',
                        messages: [{ role: 'user', content: `Generate a Twitter thread of 5 tweets about: ${cleanPrompt}\n\nEach tweet should be under 280 characters. Return as a numbered list, one tweet per line.` }],
                    }, {
                        headers: { 'Authorization': `Bearer ${validPerplexityKey}` }
                    });
                    const text = resp.data.choices[0].message.content;
                    threadTweets = text.split(/\n+/).map(line => sanitizeOutput(line.replace(/^\d+\.\s*/, ''))).filter(Boolean);
                } catch (err) {
                    aiError = err;
                }
            }
            if (provider === 'openai' && validOpenaiKey && threadTweets.length === 0) {
                try {
                    const OpenAI = require('openai');
                    const openaiClient = new OpenAI({ apiKey: validOpenaiKey });
                    const openaiPrompt = `Generate a Twitter thread of 5 tweets about: ${cleanPrompt}\n\nEach tweet should be under 280 characters. Return as a numbered list, one tweet per line.`;
                    const completion = await openaiClient.chat.completions.create({
                        model: "gpt-3.5-turbo",
                        messages: [
                            { role: "system", content: "You are a social media expert creating engaging, concise, and shareable Twitter threads." },
                            { role: "user", content: openaiPrompt }
                        ],
                        max_tokens: 500,
                        temperature: 0.8,
                    });
                    const text = completion.choices[0].message.content;
                    threadTweets = text.split(/\n+/).map(line => sanitizeOutput(line.replace(/^\d+\.\s*/, ''))).filter(Boolean);
                } catch (err) {
                    aiError = err;
                }
            }
            if (provider === 'gemini' && validGeminiKey && threadTweets.length === 0) {
                try {
                    const { GoogleGenerativeAI } = require('@google/generative-ai');
                    const genAI = new GoogleGenerativeAI(validGeminiKey);
                    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
                    const geminiPrompt = `Generate a Twitter thread of 5 tweets about: ${cleanPrompt}\n\nEach tweet should be under 280 characters. Return as a numbered list, one tweet per line.`;
                    const result = await model.generateContent([{ text: geminiPrompt }]);
                    const text = result.response.text();
                    threadTweets = text.split(/\n+/).map(line => sanitizeOutput(line.replace(/^\d+\.\s*/, ''))).filter(Boolean);
                } catch (err) {
                    aiError = err;
                }
            }
        }
        if (!Array.isArray(threadTweets) || threadTweets.length === 0) {
            return res.status(500).json({ success: false, message: 'AI did not return any tweets.', error: aiError ? aiError.message : undefined });
        }
        res.json({ success: true, tweets: threadTweets });
    } catch (error) {
        console.error('Error generating thread:', error);
        res.status(500).json({ success: false, message: 'Failed to generate thread', error: error.message });
    }
});

// --- end /generate-ai-image endpoint ---

// Post tweet to X/Twitter
app.post('/post-tweet', upload.single('image'), async (req, res) => {
    const {
        twitterApiKey,
        twitterApiSecret,
        twitterAccessToken,
        twitterAccessSecret,
        content,
        imageUrl // new: allow imageUrl in body
    } = req.body;

    // Validate all required Twitter keys
    if (!twitterApiKey || !twitterApiSecret || !twitterAccessToken || !twitterAccessSecret) {
        return res.status(400).json({
            success: false,
            message: "All Twitter API keys (API key, API secret, Access token, Access secret) are required to post a tweet."
        });
    }

    // Initialize Twitter client for this request
    const { decrypt } = require('./utils/crypto');
    let twitterClient = new TwitterApi({
        appKey: maybeDecrypt(twitterApiKey),
        appSecret: maybeDecrypt(twitterApiSecret),
        accessToken: maybeDecrypt(twitterAccessToken),
        accessSecret: maybeDecrypt(twitterAccessSecret),
    });

    try {
        if (!content) {
            return res.status(400).json({
                success: false,
                message: "Tweet content is required."
            });
        }

        if (content.length > 280) {
            return res.status(400).json({
                success: false,
                message: "Tweet content exceeds 280 characters."
            });
        }

        let mediaId = null;

        // If image is uploaded, upload it to Twitter first
        if (req.file) {
            try {
                console.log('Uploading image to Twitter...');
                const mediaUpload = await twitterClient.v1.uploadMedia(req.file.path);
                mediaId = mediaUpload;
                console.log('Image uploaded successfully, media ID:', mediaId);

                // Clean up the uploaded file
                fs.unlinkSync(req.file.path);
            } catch (imageError) {
                console.error('Error uploading image:', imageError);
                // Clean up the uploaded file
                if (fs.existsSync(req.file.path)) {
                    fs.unlinkSync(req.file.path);
                }
                return res.status(500).json({
                    success: false,
                    message: "Failed to upload image",
                    error: imageError.message
                });
            }
        } else if (imageUrl) {
            // If imageUrl is provided, fetch and upload
            try {
                console.log('Fetching image from URL for Twitter upload...');
                const response = await fetch(imageUrl);
                if (!response.ok) throw new Error('Failed to fetch image from URL');
                const buffer = await response.buffer();
                // Guess file type from URL or response headers
                let ext = 'jpg';
                if (imageUrl.endsWith('.png') || response.headers.get('content-type') === 'image/png') ext = 'png';
                const tempPath = `uploads/ai-image-${Date.now()}.${ext}`;
                fs.writeFileSync(tempPath, buffer);
                const mediaUpload = await twitterClient.v1.uploadMedia(tempPath);
                mediaId = mediaUpload;
                fs.unlinkSync(tempPath);
                console.log('Image from URL uploaded successfully, media ID:', mediaId);
            } catch (imageUrlError) {
                console.error('Error uploading image from URL:', imageUrlError);
                return res.status(500).json({
                    success: false,
                    message: "Failed to upload image from URL",
                    error: imageUrlError.message
                });
            }
        }

        // Post the tweet with or without image
        const tweetPayload = { text: content };
        if (mediaId) {
            tweetPayload.media = { media_ids: [mediaId] };
        }

        const tweet = await twitterClient.v2.tweet(tweetPayload);

        console.log('Tweet posted successfully:', tweet.data.id);

        // Save tweet to the database
        // Prevent duplicate tweet history entries
        const tweetIdVal = tweet && tweet.data && tweet.data.id ? tweet.data.id : null;
        if (tweetIdVal) {
            const existing = await Tweet.findOne({ where: { twitterId: tweetIdVal } });
            if (!existing) {
                await Tweet.create({
                    userName: req.body.userName || "Unknown",
                    content: content,
                    imageUrl: imageUrl || null,
                    twitterId: tweetIdVal,
                });
            } else {
                console.log('Duplicate tweet history prevented for Twitter ID:', tweetIdVal);
            }
        }

        res.json({
            success: true,
            message: "Tweet posted successfully!",
            tweetId: tweet.data.id,
            tweetUrl: `https://twitter.com/user/status/${tweet.data.id}`,
            hasImage: !!mediaId
        });

    } catch (error) {
        console.error('Error posting tweet:', error);

        // Clean up uploaded file if it exists
        if (req.file && fs.existsSync(req.file.path)) {
            fs.unlinkSync(req.file.path);
        }

        res.status(500).json({
            success: false,
            message: "Failed to post tweet",
            error: error.message
        });
    }
});


// This endpoint handles GET requests to /tweet-history
app.get('/tweet-history', async (req, res) => {
    try {
        const tweets = await Tweet.findAll({
            order: [['createdAt', 'DESC']]
        });
        res.json({
            success: true,
            tweets: tweets
        });
    } catch (error) {
        console.error('Error fetching tweet history:', error);
        res.status(500).json({
            success: false,
            message: "Failed to fetch tweet history",
            error: error.message
        });
    }
});

// This endpoint handles DELETE requests to /tweet-history/:id
app.delete('/tweet-history/:id', express.json(), async (req, res) => {
    try {
        const tweetId = req.params.id;
        const tweet = await Tweet.findByPk(tweetId);
        if (!tweet) {
            return res.status(404).json({ success: false, message: "Tweet not found" });
        }

        // Use credentials from request body if provided
        const { twitterApiKey, twitterApiSecret, twitterAccessToken, twitterAccessSecret } = req.body || {};
        let deleteClient = null;
        if (twitterApiKey && twitterApiSecret && twitterAccessToken && twitterAccessSecret) {
            const { TwitterApi } = require('twitter-api-v2');
            const { decrypt } = require('./utils/crypto');
            deleteClient = new TwitterApi({
                appKey: maybeDecrypt(twitterApiKey),
                appSecret: maybeDecrypt(twitterApiSecret),
                accessToken: maybeDecrypt(twitterAccessToken),
                accessSecret: maybeDecrypt(twitterAccessSecret),
            });
        } else if (global.twitterClient) {
            deleteClient = global.twitterClient;
        }

        // Delete from Twitter if twitterId exists and we have a client
        if (tweet.twitterId && deleteClient) {
            try {
                await deleteClient.v2.deleteTweet(tweet.twitterId);
            } catch (err) {
                console.error("Error deleting from Twitter:", err);
                // Optionally, you can return an error here or just log it
            }
        }
        await tweet.destroy();
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ success: false, message: "Failed to delete tweet", error: error.message });
    }
});

// Test endpoint
app.get('/ping', (req, res) => {
    res.json({ message: 'pong' });
});


// --- /post-thread endpoint ---
app.post('/post-thread', async (req, res) => {
    const {
        tweets,
        userName,
        twitterApiKey,
        twitterApiSecret,
        twitterAccessToken,
        twitterAccessSecret
    } = req.body;

    if (!Array.isArray(tweets) || tweets.length === 0) {
        return res.status(400).json({ success: false, message: 'No tweets provided.' });
    }
    if (!twitterApiKey || !twitterApiSecret || !twitterAccessToken || !twitterAccessSecret) {
        return res.status(400).json({
            success: false,
            message: "All Twitter API keys (API key, API secret, Access token, Access secret) are required to post a thread."
        });
    }

    // Initialize Twitter client for this request
    const { decrypt } = require('./utils/crypto');
    let twitterClient = new TwitterApi({
        appKey: maybeDecrypt(twitterApiKey),
        appSecret: maybeDecrypt(twitterApiSecret),
        accessToken: maybeDecrypt(twitterAccessToken),
        accessSecret: maybeDecrypt(twitterAccessSecret),
    });

    try {
        let previousTweetId = null;
        const threadIds = [];
        const threadUrls = [];
        for (let i = 0; i < tweets.length; i++) {
            const tweetText = tweets[i];
            const wordCount = tweetText.split(/\s+/).filter(Boolean).length;
            if (!tweetText || tweetText.length > 280 || wordCount > 280) {
                return res.status(400).json({
                    success: false,
                    message: `Tweet #${i + 1} is empty or exceeds 280 characters or 280 words.`
                });
            }
            const tweetPayload = { text: tweetText };
            if (previousTweetId) {
                tweetPayload.reply = { in_reply_to_tweet_id: previousTweetId };
            }
            const tweet = await twitterClient.v2.tweet(tweetPayload);
            const tweetId = tweet.data.id;
            threadIds.push(tweetId);
            threadUrls.push(`https://twitter.com/user/status/${tweetId}`);
            previousTweetId = tweetId;

            // Save each tweet to the database
            await Tweet.create({
                userName: userName || "Unknown",
                content: tweetText,
                imageUrl: null,
                twitterId: tweetId,
            });
        }
        res.json({
            success: true,
            message: `Thread posted successfully by ${userName || 'user'}`,
            threadIds,
            threadUrls
        });
    } catch (error) {
        console.error('Error posting thread:', error);
        res.status(500).json({
            success: false,
            message: "Failed to post thread",
            error: error.message
        });
    }
});
// --- /schedule-tweet endpoint ---
app.post('/schedule-tweet', async (req, res) => {
    try {
        const {
            userName,
            content,
            imageUrl,
            scheduledTime,
            twitterApiKey,
            twitterApiSecret,
            twitterAccessToken,
            twitterAccessSecret,
            userTimeZone
        } = req.body;

        // Basic validation
        if (!userName || !content || !scheduledTime || !twitterApiKey || !twitterApiSecret || !twitterAccessToken || !twitterAccessSecret) {
            return res.status(400).json({ success: false, message: 'Missing required fields.' });
        }
        if (content.length > 280) {
            return res.status(400).json({ success: false, message: 'Tweet content exceeds 280 characters.' });
        }

        // Convert scheduledTime from user's timezone to UTC
        let scheduledTimeUtc = scheduledTime;
        if (userTimeZone) {
            try {
                scheduledTimeUtc = DateTime.fromISO(scheduledTime, { zone: userTimeZone }).toUTC().toISO();
            } catch (err) {
                // fallback: use as-is
            }
        }

        // Encrypt keys before saving
        await ScheduledTweet.create({
            userName,
            content,
            imageUrl: imageUrl || null,
            scheduledTime: scheduledTimeUtc,
            twitterApiKey: encrypt(twitterApiKey),
            twitterApiSecret: encrypt(twitterApiSecret),
            twitterAccessToken: encrypt(twitterAccessToken),
            twitterAccessSecret: encrypt(twitterAccessSecret),
            status: 'pending'
        });

        res.json({ success: true, message: 'Tweet scheduled successfully!' });
    } catch (error) {
        console.error('Error scheduling tweet:', error);
        res.status(500).json({ success: false, message: 'Failed to schedule tweet', error: error.message });
    }
});


// --- View scheduled tweets endpoint ---
app.get('/scheduled-tweets', async (req, res) => {
    try {
        const scheduledTweets = await ScheduledTweet.findAll({
            order: [['scheduledTime', 'ASC']]
        });
        res.json({ success: true, scheduledTweets });
    } catch (error) {
        console.error('Error fetching scheduled tweets:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch scheduled tweets', error: error.message });
    }
});

app.post('/test-alive', (req, res) => res.json({ ok: true }));

// --- Bulk tweet generation endpoint ---
app.post('/generate-bulk-tweets', async (req, res) => {
    const { prompts, aiProviders, useOwnKeys, perplexityApiKey, geminiApiKey, openaiApiKey } = req.body;
    if (!Array.isArray(prompts) || prompts.length === 0) {
        return res.status(400).json({ success: false, message: 'No prompts provided.' });
    }
    // Limit to 25 prompts
    if (prompts.length > 25) {
        return res.status(400).json({ success: false, message: 'Maximum 25 prompts allowed.' });
    }
    // Prepare provider keys (mirroring /generate-tweet logic)
    let validPerplexityKey, validGeminiKey, validOpenaiKey, providerOrder;
    if (useOwnKeys) {
        validPerplexityKey = perplexityApiKey && typeof perplexityApiKey === 'string' && perplexityApiKey.trim() ? perplexityApiKey : null;
        validGeminiKey = geminiApiKey && typeof geminiApiKey === 'string' && geminiApiKey.trim() ? geminiApiKey : null;
        validOpenaiKey = openaiApiKey && typeof openaiApiKey === 'string' && openaiApiKey.trim() ? openaiApiKey : null;
        providerOrder = [];
        if (aiProviders && Array.isArray(aiProviders)) {
            if (validPerplexityKey && aiProviders.includes('perplexity')) providerOrder.push('perplexity');
            if (validOpenaiKey && aiProviders.includes('openai')) providerOrder.push('openai');
            if (validGeminiKey && aiProviders.includes('gemini')) providerOrder.push('gemini');
        } else {
            if (validPerplexityKey) providerOrder.push('perplexity');
            if (validOpenaiKey) providerOrder.push('openai');
            if (validGeminiKey) providerOrder.push('gemini');
        }
    } else {
        validPerplexityKey = process.env.PERPLEXITY_API_KEY && process.env.PERPLEXITY_API_KEY.trim() ? process.env.PERPLEXITY_API_KEY : null;
        validGeminiKey = process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY.trim() ? process.env.GEMINI_API_KEY : null;
        validOpenaiKey = process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY.trim() ? process.env.OPENAI_API_KEY : null;
        providerOrder = [];
        if (validPerplexityKey) providerOrder.push('perplexity');
        if (validOpenaiKey) providerOrder.push('openai');
        if (validGeminiKey) providerOrder.push('gemini');
    }
    const axios = require('axios');
    const results = [];
    for (let i = 0; i < prompts.length; i++) {
        const prompt = prompts[i];
        let generatedTweet = '';
        let error = null;
        for (const provider of providerOrder) {
            if (provider === 'perplexity' && validPerplexityKey && !generatedTweet) {
                try {
                    const resp = await axios.post('https://api.perplexity.ai/chat/completions', {
                        model: 'sonar-pro',
                        messages: [{ role: 'user', content: `Generate an engaging, creative tweet specifically about: ${prompt}. Include relevant emojis if appropriate.` }],
                    }, {
                        headers: { 'Authorization': `Bearer ${validPerplexityKey}` }
                    });
                    generatedTweet = resp.data.choices[0].message.content.trim();
                } catch (err) {
                    error = err?.response?.data || err?.message || err;
                }
            }
            if (provider === 'openai' && validOpenaiKey && !generatedTweet) {
                try {
                    const OpenAI = require('openai');
                    const openaiClient = new OpenAI({ apiKey: validOpenaiKey });
                    const completion = await openaiClient.chat.completions.create({
                        model: "gpt-3.5-turbo",
                        messages: [
                            { role: "system", content: "You are a social media expert creating engaging, concise, and shareable tweets. Keep each tweet under 280 characters, add personality, and encourage engagement." },
                            { role: "user", content: `Generate an engaging, creative tweet specifically about: ${prompt}. Include relevant emojis if appropriate.` }
                        ],
                        max_tokens: 100,
                        temperature: 0.8,
                    });
                    generatedTweet = completion.choices[0].message.content.trim();
                } catch (err) {
                    error = err?.response?.data || err?.message || err;
                }
            }
            if (provider === 'gemini' && validGeminiKey && !generatedTweet) {
                try {
                    const { GoogleGenerativeAI } = require('@google/generative-ai');
                    const geminiClient = new GoogleGenerativeAI(validGeminiKey);
                    const geminiModel = geminiClient.getGenerativeModel({ model: "gemini-1.5-flash" });
                    const result = await geminiModel.generateContent(
                        `You are a social media expert creating engaging, concise, and shareable tweets. Keep each tweet under 280 characters, add personality, and encourage engagement.\n\nGenerate an engaging, creative tweet specifically about: ${prompt}. Include relevant emojis if appropriate.`
                    );
                    const response = result.response;
                    generatedTweet = response.text().trim();
                } catch (err) {
                    error = err?.response?.data || err?.message || err;
                }
            }
        }
        // Sanitize and check length
        const cleanTweet = generatedTweet ? sanitizeOutput(generatedTweet.replace(/^[\["']|[\]"']$/g, '')) : '';
        if (cleanTweet.length > 280) {
            results.push({ prompt, tweet: '', error: 'Generated tweet exceeds 280 characters.' });
        } else if (!cleanTweet) {
            results.push({ prompt, tweet: '', error: error || 'No tweet generated.' });
        } else {
            results.push({ prompt, tweet: cleanTweet, error: null });
        }
    }
    res.json({ success: true, results });
});


app.post('/schedule-bulk-tweets', async (req, res) => {
    const { tweets, scheduleType, times, userName, twitterApiKey, twitterApiSecret, twitterAccessToken, twitterAccessSecret, dates, userTimeZone } = req.body;
    if (!Array.isArray(tweets) || tweets.length === 0) {
        return res.status(400).json({ success: false, message: 'No tweets provided.' });
    }
    if (!['once', 'twice'].includes(scheduleType)) {
        return res.status(400).json({ success: false, message: 'Invalid schedule type.' });
    }
    if (!Array.isArray(times) || times.length === 0 || times.some(t => !t)) {
        return res.status(400).json({ success: false, message: 'Invalid times.' });
    }
    // Backend guard: for 'once', only use the first time, even if more are sent
    let sanitizedTimes = times;
    if (scheduleType === 'once') {
        sanitizedTimes = [times[0]];
    }
    // dates: optional array of date strings (YYYY-MM-DD), one per tweet or one for all
    try {
        const now = new Date();
        let scheduledCount = 0;
        // Improved scheduling: pair tweets with times and increment dates as needed
        let startDate = (Array.isArray(dates) && dates.length > 0) ? dates[0] : null;
        // Use user's timezone for all date math
        const tz = userTimeZone || 'UTC';
        let currentDate = startDate
            ? DateTime.fromISO(startDate, { zone: tz })
            : DateTime.now().setZone(tz);
        let tweetIdx = 0;
        if (scheduleType === 'once') {
            // Each tweet gets its own day at the same time
            for (let i = 0; i < tweets.length; i++) {
                const { prompt, tweet } = tweets[i];
                const timeStr = sanitizedTimes[0];
                const [hours, minutes] = timeStr.split(':').map(Number);
                let scheduledDate = currentDate.set({ hour: hours, minute: minutes, second: 0, millisecond: 0 });
                // Convert to UTC before saving
                const scheduledDateUTC = scheduledDate.toUTC().toJSDate();
                // Uniqueness check
                const existing = await ScheduledTweet.findOne({
                    where: { userName, content: tweet, scheduledTime: scheduledDateUTC }
                });
                if (!existing) {
                    const { encrypt } = require('./utils/crypto');
                    await ScheduledTweet.create({
                        userName,
                        content: tweet,
                        imageUrl: null,
                        scheduledTime: scheduledDateUTC,
                        status: 'pending',
                        twitterApiKey: encrypt(twitterApiKey),
                        twitterApiSecret: encrypt(twitterApiSecret),
                        twitterAccessToken: encrypt(twitterAccessToken),
                        twitterAccessSecret: encrypt(twitterAccessSecret)
                    });
                    scheduledCount++;
                } else {
                    console.log(`Duplicate scheduled tweet prevented for user ${userName} at ${scheduledDateUTC}`);
                }
                // Move to next day
                currentDate = currentDate.plus({ days: 1 });
            }
        } else if (scheduleType === 'twice') {
            // Two tweets per day at two times, then next day for next two tweets
            for (let i = 0; i < tweets.length; i += 2) {
                for (let j = 0; j < 2; j++) {
                    if (i + j >= tweets.length) break;
                    const { prompt, tweet } = tweets[i + j];
                    const timeStr = sanitizedTimes[j];
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    let scheduledDate = currentDate.set({ hour: hours, minute: minutes, second: 0, millisecond: 0 });
                    // Convert to UTC before saving
                    const scheduledDateUTC = scheduledDate.toUTC().toJSDate();
                    // Uniqueness check
                    const existing = await ScheduledTweet.findOne({
                        where: { userName, content: tweet, scheduledTime: scheduledDateUTC }
                    });
                    if (!existing) {
                        const { encrypt } = require('./utils/crypto');
                        await ScheduledTweet.create({
                            userName,
                            content: tweet,
                            imageUrl: null,
                            scheduledTime: scheduledDateUTC,
                            status: 'pending',
                            twitterApiKey: encrypt(twitterApiKey),
                            twitterApiSecret: encrypt(twitterApiSecret),
                            twitterAccessToken: encrypt(twitterAccessToken),
                            twitterAccessSecret: encrypt(twitterAccessSecret)
                        });
                        scheduledCount++;
                    } else {
                        console.log(`Duplicate scheduled tweet prevented for user ${userName} at ${scheduledDateUTC}`);
                    }
                }
                // Move to next day after two tweets
                currentDate = currentDate.plus({ days: 1 });
            }
        }
        res.json({ success: true, message: `Scheduled ${scheduledCount} tweets.` });
    } catch (err) {
        console.error('Bulk scheduling error:', err);
        res.status(500).json({ success: false, message: 'Failed to schedule bulk tweets.', error: err.message });
    }
});
// --- Bulk scheduling endpoint (must be after app and models are initialized) ---
// Place this near other route definitions, after /schedule-tweet


// Helper: only decrypt if value looks encrypted (contains colon and is long enough)
function maybeDecrypt(key) {
    if (typeof key === 'string' && key.includes(':') && key.length > 40) {
        const { decrypt } = require('./utils/crypto');
        return decrypt(key);
    }
    return key;
}

// Start server
app.listen(PORT, () => {
    console.log(`Server is running on http://0.0.0.0:${PORT}`);
});
